{
  "author": "",
  "category": "",
  "extensionNamespace": "",
  "fullName": "Realistici 3d water",
  "helpPath": "",
  "iconUrl": "",
  "name": "water3d",
  "previewIconUrl": "",
  "shortDescription": "",
  "version": "0.0.1",
  "description": "",
  "tags": [],
  "authorIds": [
    "UL6XQkFl6HXIV2OAuAMqOJ6txuF3",
    "y06RW60iuLe1g115IK6SB4B2nAc2"
  ],
  "dependencies": [],
  "globalVariables": [],
  "sceneVariables": [],
  "eventsFunctions": [
    {
      "description": "realistic Water",
      "fullName": "water",
      "functionType": "Action",
      "name": "Realistic",
      "sentence": "realistic Water",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "\tclass Water extends THREE.Mesh {",
            "",
            "\t\tconstructor( geometry, options = {} ) {",
            "",
            "\t\t\tsuper( geometry );",
            "\t\t\tthis.isWater = true;",
            "\t\t\tconst scope = this;",
            "\t\t\tconst textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;",
            "\t\t\tconst textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;",
            "\t\t\tconst clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;",
            "\t\t\tconst alpha = options.alpha !== undefined ? options.alpha : 1.0;",
            "\t\t\tconst time = options.time !== undefined ? options.time : 0.0;",
            "\t\t\tconst normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;",
            "\t\t\tconst sunDirection = options.sunDirection !== undefined ? options.sunDirection : new THREE.Vector3( 0.70707, 0.70707, 0.0 );",
            "\t\t\tconst sunColor = new THREE.Color( options.sunColor !== undefined ? options.sunColor : 0xffffff );",
            "\t\t\tconst waterColor = new THREE.Color( options.waterColor !== undefined ? options.waterColor : 0x7F7F7F );",
            "\t\t\tconst eye = options.eye !== undefined ? options.eye : new THREE.Vector3( 0, 0, 0 );",
            "\t\t\tconst distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0;",
            "\t\t\tconst side = options.side !== undefined ? options.side : THREE.FrontSide;",
            "\t\t\tconst fog = options.fog !== undefined ? options.fog : false; //",
            "",
            "\t\t\tconst mirrorPlane = new THREE.Plane();",
            "\t\t\tconst normal = new THREE.Vector3();",
            "\t\t\tconst mirrorWorldPosition = new THREE.Vector3();",
            "\t\t\tconst cameraWorldPosition = new THREE.Vector3();",
            "\t\t\tconst rotationMatrix = new THREE.Matrix4();",
            "\t\t\tconst lookAtPosition = new THREE.Vector3( 0, 0, - 1 );",
            "\t\t\tconst clipPlane = new THREE.Vector4();",
            "\t\t\tconst view = new THREE.Vector3();",
            "\t\t\tconst target = new THREE.Vector3();",
            "\t\t\tconst q = new THREE.Vector4();",
            "\t\t\tconst textureMatrix = new THREE.Matrix4();",
            "\t\t\tconst mirrorCamera = new THREE.PerspectiveCamera();",
            "\t\t\tconst renderTarget = new THREE.WebGLRenderTarget( textureWidth, textureHeight );",
            "\t\t\tconst mirrorShader = {",
            "\t\t\t\tuniforms: THREE.UniformsUtils.merge( [ THREE.UniformsLib[ 'fog' ], THREE.UniformsLib[ 'lights' ], {",
            "\t\t\t\t\t'normalSampler': {",
            "\t\t\t\t\t\tvalue: null",
            "\t\t\t\t\t},",
            "\t\t\t\t\t'mirrorSampler': {",
            "\t\t\t\t\t\tvalue: null",
            "\t\t\t\t\t},",
            "\t\t\t\t\t'alpha': {",
            "\t\t\t\t\t\tvalue: 1.0",
            "\t\t\t\t\t},",
            "\t\t\t\t\t'time': {",
            "\t\t\t\t\t\tvalue: 0.0",
            "\t\t\t\t\t},",
            "\t\t\t\t\t'size': {",
            "\t\t\t\t\t\tvalue: 1.0",
            "\t\t\t\t\t},",
            "\t\t\t\t\t'distortionScale': {",
            "\t\t\t\t\t\tvalue: 50.0",
            "\t\t\t\t\t},",
            "\t\t\t\t\t'textureMatrix': {",
            "\t\t\t\t\t\tvalue: new THREE.Matrix4()",
            "\t\t\t\t\t},",
            "\t\t\t\t\t'sunColor': {",
            "\t\t\t\t\t\tvalue: new THREE.Color( 0x7F7F7F )",
            "\t\t\t\t\t},",
            "\t\t\t\t\t'sunDirection': {",
            "\t\t\t\t\t\tvalue: new THREE.Vector3( 0.70707, 0.70707, 0 )",
            "\t\t\t\t\t},",
            "\t\t\t\t\t'eye': {",
            "\t\t\t\t\t\tvalue: new THREE.Vector3()",
            "\t\t\t\t\t},",
            "\t\t\t\t\t'waterColor': {",
            "\t\t\t\t\t\tvalue: new THREE.Color( 0x555555 )",
            "\t\t\t\t\t}",
            "\t\t\t\t} ] ),",
            "\t\t\t\tvertexShader:",
            "      /* glsl */",
            "      `",
            "\t\t\t\tuniform mat4 textureMatrix;",
            "\t\t\t\tuniform float time;",
            "",
            "\t\t\t\tvarying vec4 mirrorCoord;",
            "\t\t\t\tvarying vec4 worldPosition;",
            "",
            "\t\t\t\t#include <common>",
            "\t\t\t\t#include <fog_pars_vertex>",
            "\t\t\t\t#include <shadowmap_pars_vertex>",
            "\t\t\t\t#include <logdepthbuf_pars_vertex>",
            "",
            "\t\t\t\tvoid main() {",
            "\t\t\t\t\tmirrorCoord = modelMatrix * vec4( position, 1.0 );",
            "\t\t\t\t\tworldPosition = mirrorCoord.xyzw;",
            "\t\t\t\t\tmirrorCoord = textureMatrix * mirrorCoord;",
            "\t\t\t\t\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );",
            "\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;",
            "",
            "\t\t\t\t#include <beginnormal_vertex>",
            "\t\t\t\t#include <defaultnormal_vertex>",
            "\t\t\t\t#include <logdepthbuf_vertex>",
            "\t\t\t\t#include <fog_vertex>",
            "\t\t\t\t#include <shadowmap_vertex>",
            "\t\t\t}`,",
            "\t\t\t\tfragmentShader:",
            "      /* glsl */",
            "      `",
            "\t\t\t\tuniform sampler2D mirrorSampler;",
            "\t\t\t\tuniform float alpha;",
            "\t\t\t\tuniform float time;",
            "\t\t\t\tuniform float size;",
            "\t\t\t\tuniform float distortionScale;",
            "\t\t\t\tuniform sampler2D normalSampler;",
            "\t\t\t\tuniform vec3 sunColor;",
            "\t\t\t\tuniform vec3 sunDirection;",
            "\t\t\t\tuniform vec3 eye;",
            "\t\t\t\tuniform vec3 waterColor;",
            "",
            "\t\t\t\tvarying vec4 mirrorCoord;",
            "\t\t\t\tvarying vec4 worldPosition;",
            "",
            "\t\t\t\tvec4 getNoise( vec2 uv ) {",
            "\t\t\t\t\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);",
            "\t\t\t\t\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );",
            "\t\t\t\t\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );",
            "\t\t\t\t\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );",
            "\t\t\t\t\tvec4 noise = texture2D( normalSampler, uv0 ) +",
            "\t\t\t\t\t\ttexture2D( normalSampler, uv1 ) +",
            "\t\t\t\t\t\ttexture2D( normalSampler, uv2 ) +",
            "\t\t\t\t\t\ttexture2D( normalSampler, uv3 );",
            "\t\t\t\t\treturn noise * 0.5 - 1.0;",
            "\t\t\t\t}",
            "",
            "\t\t\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {",
            "\t\t\t\t\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );",
            "\t\t\t\t\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );",
            "\t\t\t\t\tspecularColor += pow( direction, shiny ) * sunColor * spec;",
            "\t\t\t\t\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;",
            "\t\t\t\t}",
            "",
            "\t\t\t\t#include <common>",
            "\t\t\t\t#include <packing>",
            "\t\t\t\t#include <bsdfs>",
            "\t\t\t\t#include <fog_pars_fragment>",
            "\t\t\t\t#include <logdepthbuf_pars_fragment>",
            "\t\t\t\t#include <lights_pars_begin>",
            "\t\t\t\t#include <shadowmap_pars_fragment>",
            "\t\t\t\t#include <shadowmask_pars_fragment>",
            "",
            "\t\t\t\tvoid main() {",
            "",
            "\t\t\t\t\t#include <logdepthbuf_fragment>",
            "\t\t\t\t\tvec4 noise = getNoise( worldPosition.xz * size );",
            "\t\t\t\t\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );",
            "",
            "\t\t\t\t\tvec3 diffuseLight = vec3(0.0);",
            "\t\t\t\t\tvec3 specularLight = vec3(0.0);",
            "",
            "\t\t\t\t\tvec3 worldToEye = eye-worldPosition.xyz;",
            "\t\t\t\t\tvec3 eyeDirection = normalize( worldToEye );",
            "\t\t\t\t\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );",
            "",
            "\t\t\t\t\tfloat distance = length(worldToEye);",
            "",
            "\t\t\t\t\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;",
            "\t\t\t\t\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );",
            "",
            "\t\t\t\t\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );",
            "\t\t\t\t\tfloat rf0 = 0.3;",
            "\t\t\t\t\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );",
            "\t\t\t\t\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;",
            "\t\t\t\t\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);",
            "\t\t\t\t\tvec3 outgoingLight = albedo;",
            "\t\t\t\t\tgl_FragColor = vec4( outgoingLight, alpha );",
            "",
            "\t\t\t\t\t#include <tonemapping_fragment>",
            "\t\t\t\t\t#include <fog_fragment>",
            "\t\t\t\t}`",
            "\t\t\t};",
            "\t\t\tconst material = new THREE.ShaderMaterial( {",
            "\t\t\t\tfragmentShader: mirrorShader.fragmentShader,",
            "\t\t\t\tvertexShader: mirrorShader.vertexShader,",
            "\t\t\t\tuniforms: THREE.UniformsUtils.clone( mirrorShader.uniforms ),",
            "\t\t\t\tlights: true,",
            "\t\t\t\tside: side,",
            "\t\t\t\tfog: fog",
            "\t\t\t} );",
            "\t\t\tmaterial.uniforms[ 'mirrorSampler' ].value = renderTarget.texture;",
            "\t\t\tmaterial.uniforms[ 'textureMatrix' ].value = textureMatrix;",
            "\t\t\tmaterial.uniforms[ 'alpha' ].value = alpha;",
            "\t\t\tmaterial.uniforms[ 'time' ].value = time;",
            "\t\t\tmaterial.uniforms[ 'normalSampler' ].value = normalSampler;",
            "\t\t\tmaterial.uniforms[ 'sunColor' ].value = sunColor;",
            "\t\t\tmaterial.uniforms[ 'waterColor' ].value = waterColor;",
            "\t\t\tmaterial.uniforms[ 'sunDirection' ].value = sunDirection;",
            "\t\t\tmaterial.uniforms[ 'distortionScale' ].value = distortionScale;",
            "\t\t\tmaterial.uniforms[ 'eye' ].value = eye;",
            "\t\t\tscope.material = material;",
            "",
            "\t\t\tscope.onBeforeRender = function ( renderer, scene, camera ) {",
            "",
            "\t\t\t\tmirrorWorldPosition.setFromMatrixPosition( scope.matrixWorld );",
            "\t\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );",
            "\t\t\t\trotationMatrix.extractRotation( scope.matrixWorld );",
            "\t\t\t\tnormal.set( 0, 0, 1 );",
            "\t\t\t\tnormal.applyMatrix4( rotationMatrix );",
            "\t\t\t\tview.subVectors( mirrorWorldPosition, cameraWorldPosition ); // Avoid rendering when mirror is facing away",
            "",
            "\t\t\t\tif ( view.dot( normal ) > 0 ) return;",
            "\t\t\t\tview.reflect( normal ).negate();",
            "\t\t\t\tview.add( mirrorWorldPosition );",
            "\t\t\t\trotationMatrix.extractRotation( camera.matrixWorld );",
            "\t\t\t\tlookAtPosition.set( 0, 0, - 1 );",
            "\t\t\t\tlookAtPosition.applyMatrix4( rotationMatrix );",
            "\t\t\t\tlookAtPosition.add( cameraWorldPosition );",
            "\t\t\t\ttarget.subVectors( mirrorWorldPosition, lookAtPosition );",
            "\t\t\t\ttarget.reflect( normal ).negate();",
            "\t\t\t\ttarget.add( mirrorWorldPosition );",
            "\t\t\t\tmirrorCamera.position.copy( view );",
            "\t\t\t\tmirrorCamera.up.set( 0, 1, 0 );",
            "\t\t\t\tmirrorCamera.up.applyMatrix4( rotationMatrix );",
            "\t\t\t\tmirrorCamera.up.reflect( normal );",
            "\t\t\t\tmirrorCamera.lookAt( target );",
            "\t\t\t\tmirrorCamera.far = camera.far; // Used in WebGLBackground",
            "",
            "\t\t\t\tmirrorCamera.updateMatrixWorld();",
            "\t\t\t\tmirrorCamera.projectionMatrix.copy( camera.projectionMatrix ); // Update the texture matrix",
            "",
            "\t\t\t\ttextureMatrix.set( 0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0 );",
            "\t\t\t\ttextureMatrix.multiply( mirrorCamera.projectionMatrix );",
            "\t\t\t\ttextureMatrix.multiply( mirrorCamera.matrixWorldInverse ); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html",
            "\t\t\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf",
            "",
            "\t\t\t\tmirrorPlane.setFromNormalAndCoplanarPoint( normal, mirrorWorldPosition );",
            "\t\t\t\tmirrorPlane.applyMatrix4( mirrorCamera.matrixWorldInverse );",
            "\t\t\t\tclipPlane.set( mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant );",
            "\t\t\t\tconst projectionMatrix = mirrorCamera.projectionMatrix;",
            "\t\t\t\tq.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];",
            "\t\t\t\tq.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];",
            "\t\t\t\tq.z = - 1.0;",
            "\t\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ]; // Calculate the scaled plane vector",
            "",
            "\t\t\t\tclipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) ); // Replacing the third row of the projection matrix",
            "",
            "\t\t\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;",
            "\t\t\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;",
            "\t\t\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;",
            "\t\t\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;",
            "\t\t\t\teye.setFromMatrixPosition( camera.matrixWorld ); // Render",
            "",
            "\t\t\t\tconst currentRenderTarget = renderer.getRenderTarget();",
            "\t\t\t\tconst currentXrEnabled = renderer.xr.enabled;",
            "\t\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;",
            "\t\t\t\tscope.visible = false;",
            "\t\t\t\trenderer.xr.enabled = false; // Avoid camera modification and recursion",
            "",
            "\t\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows",
            "",
            "\t\t\t\trenderer.setRenderTarget( renderTarget );",
            "\t\t\t\trenderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897",
            "",
            "\t\t\t\tif ( renderer.autoClear === false ) renderer.clear();",
            "\t\t\t\trenderer.render( scene, mirrorCamera );",
            "\t\t\t\tscope.visible = true;",
            "\t\t\t\trenderer.xr.enabled = currentXrEnabled;",
            "\t\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;",
            "\t\t\t\trenderer.setRenderTarget( currentRenderTarget ); // Restore viewport",
            "",
            "\t\t\t\tconst viewport = camera.viewport;",
            "",
            "\t\t\t\tif ( viewport !== undefined ) {",
            "",
            "\t\t\t\t\trenderer.state.viewport( viewport );",
            "",
            "\t\t\t\t}",
            "",
            "\t\t\t};",
            "",
            "\t\t}",
            "",
            "\t}",
            "",
            "\tTHREE.Water = Water;",
            "",
            "",
            "const renderer = runtimeScene.getGame().getRenderer().getThreeRenderer();",
            "const scene3D = runtimeScene.getLayer('Base layer').getRenderer().getThreeScene();",
            "const camera1 = runtimeScene.getLayer('Base layer').getRenderer().getThreeCamera();",
            "",
            "",
            "const sunLight = new THREE.DirectionalLight(0xffffff, 0.9); ",
            "sunLight.position.set(1000, 1000, 1000);  ",
            "sunLight.castShadow = false; ",
            "sunLight.shadow.mapSize.width = 2048; ",
            "sunLight.shadow.mapSize.height = 2048;",
            "//size of the water",
            "const waterGeometry = new THREE.PlaneGeometry(2000, 2000);",
            "",
            "const water = new THREE.Water(",
            "    waterGeometry,",
            "    {",
            "        alpha: 0.8,",
            "        sunDirection: new THREE.Vector3(0,1,0),",
            "        sunColor: 0xffffff,",
            "        waterColor: 0x001e0f, // Color oscuro del agua",
            "        distortionScale: 3.7, // Ajustar la escala de distorsión para un efecto más realista",
            "    }",
            ");",
            "",
            "",
            "// 3. Position of the water",
            "water.rotation.x = 0; ",
            "water.position.x= 0;",
            "water.position.y = 0; ",
            "water.position.z = 0.3;  ",
            "scene3D.add(water);",
            "/*scene3D.add(water);*/",
            "",
            "",
            "// 5. Animación del agua",
            "function animateWater() {",
            "  water.material.transparent = true; ",
            "   water.material.fog = false; ",
            "water.material.uniforms['alpha'].value = 0.80; ",
            "  water.material.uniforms['time'].value += 1.0 / 600.0; ",
            "    const time = performance.now() * 0.001;  ",
            "    water.material.uniforms['time'].value += 1.0 / 60.0; ",
            "    water.material.uniforms['sunDirection'].value.copy(sunLight.position).normalize(); ",
            "    requestAnimationFrame(animateWater);",
            "}",
            "animateWater();",
            "",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [],
  "eventsBasedObjects": []
}